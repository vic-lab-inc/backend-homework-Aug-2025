
    /* ===================== 1. Two Sum (LC 1) ===================== */
    // Approach: HashMap (value -> index). One-pass scan.
    // Time O(n), Space O(n)
    public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> idx = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int need = target - nums[i];
            if (idx.containsKey(need)) return new int[]{idx.get(need), i};
            idx.put(nums[i], i);
        }
        return new int[0];
    }

    /* ===== 3. Longest Substring Without Repeating Characters (LC 3) ===== */
    // Approach: Sliding window + last seen index array.
    // Time O(n), Space O(Σ) where Σ is character set size
    public static int lengthOfLongestSubstring(String s) {
        int[] last = new int[256];
        Arrays.fill(last, -1);
        int left = 0, ans = 0;
        for (int r = 0; r < s.length(); r++) {
            char c = s.charAt(r);
            if (last[c] >= left) left = last[c] + 1;
            last[c] = r;
            ans = Math.max(ans, r - left + 1);
        }
        return ans;
    }

    /* =========== 5. Longest Palindromic Substring (LC 5) =========== */
    // Approach: Expand around center.
    // Time O(n^2), Space O(1)
    public static String longestPalindrome(String s) {
        if (s == null || s.length() < 2) return s;
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start + 1) {
                int half = (len - 1) / 2;
                start = i - half;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }
    private static int expand(String s, int l, int r) {
        while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) { l--; r++; }
        return r - l - 1;
    }

    /* ====== 11. Container With Most Water (LC 11) ====== */
    // Approach: Two pointers, move the shorter line.
    // Time O(n), Space O(1)
    public static int maxArea(int[] height) {
        int l = 0, r = height.length - 1, ans = 0;
        while (l < r) {
            ans = Math.max(ans, Math.min(height[l], height[r]) * (r - l));
            if (height[l] < height[r]) l++; else r--;
        }
        return ans;
    }

    /* ====== 128. Longest Consecutive Sequence (LC 128) ====== */
    // Approach: HashSet, only start counting from sequence heads.
    // Time O(n), Space O(n)
    public static int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int x : nums) set.add(x);
        int ans = 0;
        for (int x : set) {
            if (!set.contains(x - 1)) {
                int cur = x, len = 1;
                while (set.contains(cur + 1)) { cur++; len++; }
                ans = Math.max(ans, len);
            }
        }
        return ans;
    }

    /* ====== 133. Clone Graph (LC 133) ====== */
    // Approach: BFS (or DFS) with HashMap old->new node.
    // Time O(V+E), Space O(V)
    public static Node cloneGraph(Node node) {
        if (node == null) return null;
        Map<Node, Node> map = new HashMap<>();
        Queue<Node> q = new LinkedList<>();
        map.put(node, new Node(node.val));
        q.offer(node);
        while (!q.isEmpty()) {
            Node cur = q.poll();
            for (Node nei : cur.neighbors) {
                if (!map.containsKey(nei)) {
                    map.put(nei, new Node(nei.val));
                    q.offer(nei);
                }
                map.get(cur).neighbors.add(map.get(nei));
            }
        }
        return map.get(node);
    }

    /* ====== 139. Word Break (LC 139) ====== */
    // Approach: DP, dp[i] means s[0..i-1] can be segmented.
    // Time O(n * L), Space O(n), where L = max word length
    public static boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>(wordDict);
        int maxLen = 0;
        for (String w : wordDict) maxLen = Math.max(maxLen, w.length());
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int l = 1; l <= maxLen && l <= i; l++) {
                if (!dp[i - l]) continue;
                if (set.contains(s.substring(i - l, i))) { dp[i] = true; break; }
            }
        }
        return dp[s.length()];
    }

    /* ====== 141. Linked List Cycle (LC 141) ====== */
    // Approach: Floyd's cycle detection (fast/slow pointers).
    // Time O(n), Space O(1)
    public static boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            if (slow == fast) return true;
            slow = slow.next;
            fast = fast.next.next;
        }
        return false;
    }

    /* ====== 261. Graph Valid Tree (LC 261) ====== */
    // Condition: edges == n-1 AND graph is connected (no cycle).
    // Approach: Union-Find.
    // Time O(n + m α(n)), Space O(n)
    public static boolean validTree(int n, int[][] edges) {
        if (edges.length != n - 1) return false;
        UnionFind uf = new UnionFind(n);
        for (int[] e : edges) {
            if (!uf.union(e[0], e[1])) return false; // cycle detected
        }
        return true;
    }

    /* ====== 647. Palindromic Substrings (LC 647) ====== */
    // Approach: Expand around center, count palindromes.
    // Time O(n^2), Space O(1)
    public static int countSubstrings(String s) {
        int n = s.length(), ans = 0;
        for (int center = 0; center < 2 * n - 1; center++) {
            int l = center / 2;
            int r = l + (center % 2);
            while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
                ans++; l--; r++;
            }
        }
        return ans;
    }

    /* =================== Helper Data Structures =================== */
    // For LC 141
    public static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) { val = x; }
    }

    // For LC 133
    public static class Node {
        public int val;
        public List<Node> neighbors;
        public Node() { val = 0; neighbors = new ArrayList<>(); }
        public Node(int _val) { val = _val; neighbors = new ArrayList<>(); }
        public Node(int _val, ArrayList<Node> _neighbors) { val = _val; neighbors = _neighbors; }
    }

    // Union-Find for LC 261
    static class UnionFind {
        int[] parent, rank;
        UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }
        int find(int x) {
            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }
        boolean union(int a, int b) {
            int pa = find(a), pb = find(b);
            if (pa == pb) return false;
            if (rank[pa] < rank[pb]) parent[pa] = pb;
            else if (rank[pb] < rank[pa]) parent[pb] = pa;
            else { parent[pb] = pa; rank[pa]++; }
            return true;
        }
    }


