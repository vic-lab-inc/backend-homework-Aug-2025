- ### **What is Maven?**

Maven is a build automation and project management tool used primarily for Java projects.

- ### **What is a POM file in Maven?**

Core config file for dependencies, plugins, build settings, etc.

- ### **What is the difference between dependencies and dependencyManagement?**

`<dependencies>` is where you declare the actual libraries your project needs, and those JARs are added directly to the classpath. `<dependencyManagement>` doesn’t bring in any dependency by itself，it’s mainly used to define versions and scopes in a central place, usually in a parent POM, so child modules or dependencies can inherit those settings without repeating version numbers. In short, `<dependencies>` adds the library, while `<dependencyManagement>` just manages consistent versions across the project.

- ### **What is a transitive dependency in Maven?**

A transitive dependency in Maven is an indirect dependency that your project gets because one of your direct dependencies depends on it. For example, if your project depends on library **A**, and **A** internally depends on library **B**, then **B** is pulled into your project automatically as a transitive dependency. This makes dependency management easier since you don’t have to explicitly declare everything, but it can also lead to conflicts if different libraries bring in different versions of the same dependency.

- ### **What is the difference between a snapshot and a release in Maven?**

In Maven, a **release** version is a fixed, immutable build meant for production. Once deployed, it should never change, and it is considered stable. A **snapshot** version is a development version that can change over time. Maven will check remote repositories for newer timestamped builds of a snapshot and update them automatically.

- ### **What are some commonly used Maven plugins?**

  - **maven-compiler-plugin** – compiles Java source code.

  - **maven-surefire-plugin** – runs unit tests.

  - **maven-failsafe-plugin** – runs integration tests.

  - **maven-jar-plugin** – builds JAR files.

  - **maven-war-plugin** – builds WAR files for web applications.

  - **maven-clean-plugin** – cleans the target directory.

  - **maven-install-plugin** – installs the artifact into the local repository.

  - **maven-deploy-plugin** – deploys artifacts to a remote repository.

  - **maven-site-plugin** – generates project documentation.

​     **In short:** compiler for building, surefire/failsafe for testing, jar/war for packaging, and clean/install/deploy for lifecycle management.

- ### **What is Maven lifecycle?**

The **Maven life cycle** is a **set of well-defined phases** that manage the **build process** of a project

There are three built-in build lifecycles: **default**, **clean** and **site**. The `default` lifecycle handles your project deployment, the `clean` lifecycle handles project cleaning, while the `site` lifecycle handles the creation of your project's web site.

- ### **What are some common lifecycle phases?**

  - `validate` - validate the project is correct and all necessary information is available
  - `compile` - compile the source code of the project
  - `test` - test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed
  - `package` - take the compiled code and package it in its distributable format, such as a **JAR**.
  - `verify` - run any checks on results of integration tests to ensure quality criteria are met
  - `install` - install the package into the **local repository**, for use as a dependency in other projects locally
  - `deploy` - done in the build environment, copies the final package to the remote repository for sharing with other developers and projects.

- ### **What is the difference between mvn package and mvn install?**

  - **`mvn package`** – compiles the code, runs tests, and packages the application inside the project’s target directory.
  - **`mvn install`** – does everything `package` does, and in addition, it installs the built artifact into the **local Maven repository** (`~/.m2/repository`) so it can be used as a dependency in other local projects.
  - **Use mvn package** when you’re just building and testing your project.
  - **Use mvn install** when you want to **use this project as a dependency** in another local project.

- ### **What is the difference between git fetch and git pull?**

  - **`git fetch`** downloads new commits, branches, and tags from the remote repository, but it does **not** change your working directory or current branch. It only updates your local tracking references.

  - **`git pull`** is essentially `git fetch` **followed by** `git merge` (or `git rebase` if configured). It not only downloads the new commits but also updates your current branch with them.

  - **In short:**

  - `fetch` = just downloads updates.

  - `pull` = downloads + integrates updates into your current branch.
  - `git fetch` is safer because it lets you review incoming changes before merging, while `git pull` merges immediately.

- ### **What is the difference between git merge and git rebase? Pro and Cons?**

  - **`git merge`**: Combines changes from one branch into another by creating a new **merge commit**. The branch history remains unchanged and non-linear.
    - **Pros:** Preserves complete history, simple and safe, avoids rewriting commits.
    - **Cons:** History can become cluttered with many merge commits, harder to read.
  - **`git rebase`**: Moves or “replays” your branch’s commits on top of another branch, rewriting history to look linear.
    - **Pros:** Cleaner, linear history, easier to follow with `git log`.
    - **Cons:** Rewrites commit history, which can be dangerous if already pushed/shared (may cause conflicts for collaborators).

- ### **How do you resolve merge conflicts in Git?**

  A merge conflict happens when Git can’t automatically combine changes. When that happens, I check with `git status` to see which files are in conflict. Then I open those files, look at the conflict markers, and decide whether to keep my changes, the incoming changes, or a mix of both. After I clean up the file and remove the markers, I stage it with `git add`, and then finish with `git commit` or `git rebase --continue`. If I mess up, I can always use `git merge --abort` or `git rebase --abort` to start over.



- #### **What is the purpose of .gitignore?**

  The `.gitignore` file tells Git which files or directories should be ignored and not tracked in version control. This is useful for excluding things like build artifacts, temporary files, logs, IDE settings, or sensitive configuration files that should not be committed.

- ### **How do you undo a commit that has already been pushed?**

  - **`git revert`** (Safe way, preferred for shared branches)
    - Creates a new commit that reverses the changes of a previous commit.
    - Keeps history intact, avoids rewriting commits.
    - Recommended for undoing changes on a public branch.

- ### **Can you give me some common git commands?**

  - git clone   copy a remote repository locally
  - git status  show the current state of the working directory and staging area
  - git add     stage changes for the next commit
  - git commit  save staged changes as a commit
  - git push    upload local commits to a remote repository
  - git pull    fetch + merge changes from remote
  - git branch  list, create, or delete branches
  - git merge   merge another branch into the current branch
  - git rebase  make a nice linear sequence of commits
  - git fetch   download changes from remote without merging